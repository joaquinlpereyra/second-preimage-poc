"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WMerkleTree = void 0;
const ethers_1 = require("ethers");
var WMerkleTree_1 = require("./WMerkleTree");
Object.defineProperty(exports, "WMerkleTree", { enumerable: true, get: function () { return __importDefault(WMerkleTree_1).default; } });
const BYTE_TYPES = [
    'bytes32',
    'bytes16',
    'bytes8',
    'bytes4',
    'bytes2',
    'bytes1',
    'byte',
    'bytes',
];
const UINT_TYPES = [
    'uint256',
    'uint128',
    'uint64',
    'uint32',
    'uint16',
    'uint8',
    'uint4',
    'uint2',
    'uint1',
    'uint',
];
exports.default = {
    blankFromType(type) {
        type = type.toLowerCase();
        if (BYTE_TYPES.includes(type))
            return ethers_1.ethers.constants.HashZero;
        else if (type === 'address') {
            return ethers_1.ethers.constants.AddressZero;
        }
        else if (UINT_TYPES.includes(type)) {
            return ethers_1.ethers.constants.Zero;
        }
        else if (type === 'bool') {
            return false;
        }
        else if (type == 'string') {
            return '';
        }
        else {
            throw new Error(`Unknown type ${type} converting  to blank`);
        }
    },
    getBlankLeaf(leafSignature) {
        const retVal = leafSignature.map(l => this.blankFromType(l.type));
        return retVal;
    },
    /**
     * Hash a leaf to be used in the merkle tree
     * @param values Leaf to hash
     * @returns Hash of the leaf
     */
    hashLeaf(values, signature) {
        return ('0x' +
            Buffer.from(ethers_1.ethers.utils
                .solidityKeccak256(signature.map(p => p.type), // Types
            values)
                .slice(2), 'hex').toString('hex'));
    },
    getObjectValues(sourceItem, signature) {
        const objectKeys = Object.keys(sourceItem);
        if (signature.length > objectKeys.length)
            throw new Error('Source item has less attributes than Leaf Signature parameters.');
        let retVal = [];
        for (let functionParameter of signature) {
            if (!objectKeys.includes(functionParameter.name))
                throw new Error('Source object does not contain attribute with name ' +
                    functionParameter.name);
            let value = sourceItem[functionParameter.name];
            if (ethers_1.BigNumber.isBigNumber(value))
                ethers_1.BigNumber.from(value); // Make a new instance.
            retVal.push(value);
        }
        return retVal;
    },
};
