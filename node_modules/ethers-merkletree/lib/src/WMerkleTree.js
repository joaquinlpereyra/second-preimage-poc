"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const keccak256_1 = __importDefault(require("keccak256"));
const merkletreejs_1 = __importDefault(require("merkletreejs"));
const _1 = __importDefault(require("."));
class WMerkleTree {
    constructor(sourceItems, signature, options = {
        sortPairs: true,
        sortLeaves: false,
        throwOnUneven: false,
    }) {
        if (sourceItems.length === 0)
            throw new Error('Invalid empty whitelist');
        this._sourceItems = sourceItems;
        if (signature.length == 0)
            throw new Error('Invalid empty signature definition');
        this._signature = signature;
        this._leaves = sourceItems.map(i => _1.default.getObjectValues(i, signature));
        if (this._leaves.length % 2 !== 0) {
            if (options.throwOnUneven)
                throw new Error('whitelist entries must be even');
            else {
                this._leaves.push(_1.default.getBlankLeaf(signature));
            }
        }
        // Initialize base merkle tree
        this._baseTree = new merkletreejs_1.default(this._leaves.map(l => _1.default.hashLeaf(l, this._signature)), keccak256_1.default, { sortPairs: options.sortPairs, sortLeaves: options.sortLeaves });
    }
    get merkleTree() {
        return this._baseTree;
    }
    get leaves() {
        return this._leaves;
    }
    get sourceItems() {
        return this._sourceItems;
    }
    get signature() {
        return this._signature;
    }
    hashLeafIndex(leafIndex) {
        return _1.default.hashLeaf(this.leaves[leafIndex], this._signature);
    }
    getHexProof(leafIndex) {
        return this._baseTree.getHexProof(this.hashLeafIndex(leafIndex));
    }
    getHexRoot() {
        return this._baseTree.getHexRoot();
    }
}
exports.default = WMerkleTree;
